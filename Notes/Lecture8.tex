\section*{Lecture 8: MPI - Message Passing Interface}
\codebox{\textbf{Hello World in MPI}}

\begin{lstlisting}
#include <bits/stdc++.h>
#include <mpi.h>

using namespace std;

int main(int argc, char** argv) {

    MPI_Init(&argc, &argv); 

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); /* Get Process Rank */
    MPI_Comm_size(MPI_COMM_WORLD, &size); /* Get Total Number of Process */

    cout << "Hello from process: " << rank << "/" << size << endl;

    MPI_Finalize();
    return 0;   

    /* To compile use: mpic++ Helloworld.cpp -o Executable; mpirun -np 2 ./Executable */
    /* -np 2 means 2 processes */
    /* Output:
     Hello from process: 0/2
     Hello from process: 1/2
    */
}
\end{lstlisting}

\codebox{\textbf{MPI\_Send and MPI\_Recv Program 1}} In this program we will send and receive one variable. We need to follow this syntax:
\begin{lstlisting}
/* MPI_Send(&data, count, datatype, destination, tag, communicator); tag message identifier and can be any integer */
/* MPI_Recv(&data, count, datatype, source, tag, communicator, &status); status returns info about received message*/

int main(int argc, char** argv) {
    MPI_Init(&argc, &argv);

    int rank;
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);

    if(rank == 0) {
        int data = 40;
        MPI_Send(&data,1,MPI_INT,1,0,MPI_COMM_WORLD); 
        cout << "Process 0 sent: " << data << " to Process 1" << endl;
    }    
    else if(rank == 1) {
        int receivedData;
        MPI_Status status;
        MPI_Recv(&receivedData,1,MPI_INT,0,0,MPI_COMM_WORLD,&status); 
        cout << "Process 1 received: " << receivedData << " from Process 0" << endl;
    }
    
    MPI_Finalize();
    return 0;
}
\end{lstlisting}

\codebox{\textbf{MPI\_Send and MPI\_Recv Program 2}} In this program we will send and receive arrays or parts of arrays.

\begin{lstlisting}
int main(int argc, char** argv) {
    MPI_Init(&argc, &argv);
    MPI_Comm comm = MPI_COMM_WORLD;

    int rank;
    MPI_Comm_rank(comm,&rank);

    vector<int> nums(10,1);

    if(rank == 0) {
        for(int i = 0;i <= 4; i++) nums[i]++;

        MPI_Send(&nums[5],5,MPI_INT,1,0,comm); /* Send Half of the Elements */
        MPI_Status status; MPI_Recv(&nums[5],5,MPI_INT,1,0,comm,&status); /* Receive Processed Elements */
    }

    if(rank == 1) {
        MPI_Status status; MPI_Recv(&nums[5],5,MPI_INT,0,0,comm,&status); /* Receive Elements to Process */
                
        for(int i = 5;i <= 9; i++) nums[i]++;
        MPI_Send(&nums[5],5,MPI_INT,0,0,comm); /* Send Back Processes Elements all at once */
        
    }

    cout << "Work Completed for Process: " << rank << endl;
    cout << "Updated Array: ";
    for(int i = 0;i < 10; i++) cout << nums[i] << " ";
    cout << endl;
    MPI_Finalize();
    
    return 0;
}
\end{lstlisting}

\subsection*{Point to Point Communication}
This includes sending and receiving messages between two processes. The syntax is: \\
\begin{lstlisting}
MPI_Send(&data, count, datatype, destination, tag, communicator);
MPI_Recv(&data, count, datatype, source, tag, communicator, &status);
MPI_Get_count(&status, datatype, &count);

//Tag can be any integer and is used to identify the message, status is a structure that contains information about the received message.
\end{lstlisting}

\subsection*{Communication Scope and Communicator}
The \textbf{communication scope} defines the set of processes that can communicate with each other. This is determined by the communicator used. \\
A \textbf{Communicator} is an MPI\_Object that defines a group of processes that can communicate with each other.\\ MPI\_COMM\_WORLD is the default communicator that includes all processes. \\